[
  {
    "type": "Function",
    "name": "string",
    "description": "Casts the input to a string.",
    "args": "input, prettify",
    "returns": "string",
    "code": "(input, prettify = false) => {\n    return JSON.stringify(input, null, prettify ? 2 : 0);\n}"
  },
  {
    "type": "Function",
    "name": "$string",
    "description": "Casts the input to a string.",
    "args": "input, prettify",
    "returns": "string",
    "code": "(input, prettify = false) => {\n    return JSON.stringify(input, null, prettify ? 2 : 0);\n}"
  },
  {
    "type": "Function",
    "name": "length",
    "description": "Returns the number of characters in a string, or the length of an array.",
    "args": "input",
    "returns": "number",
    "code": "(input) => {\n    if (typeof input === 'string') {\n        return input.length;\n    }\n    if (Array.isArray(input)) {\n        return input.length;\n    }\n    if (typeof input === 'object' && input !== null) {\n        return Object.keys(input).length;\n    }\n    return 0;\n}"
  },
  {
    "type": "Function",
    "name": "$length",
    "description": "Returns the number of characters in a string, or the length of an array.",
    "args": "input",
    "returns": "number",
    "code": "(input) => {\n    if (typeof input === 'string') {\n        return input.length;\n    }\n    if (Array.isArray(input)) {\n        return input.length;\n    }\n    if (typeof input === 'object' && input !== null) {\n        return Object.keys(input).length;\n    }\n    return 0;\n}"
  },
  {
    "type": "Function",
    "name": "count",
    "description": "Returns the number of characters in a string, or the length of an array.",
    "args": "input",
    "returns": "number",
    "code": "(input) => {\n    if (typeof input === 'string') {\n        return input.length;\n    }\n    if (Array.isArray(input)) {\n        return input.length;\n    }\n    if (typeof input === 'object' && input !== null) {\n        return Object.keys(input).length;\n    }\n    return 0;\n}"
  },
  {
    "type": "Function",
    "name": "$count",
    "description": "Returns the number of characters in a string, or the length of an array.",
    "args": "input",
    "returns": "number",
    "code": "(input) => {\n    if (typeof input === 'string') {\n        return input.length;\n    }\n    if (Array.isArray(input)) {\n        return input.length;\n    }\n    if (typeof input === 'object' && input !== null) {\n        return Object.keys(input).length;\n    }\n    return 0;\n}"
  },
  {
    "type": "Function",
    "name": "size",
    "description": "Returns the number of characters in a string, or the length of an array.",
    "args": "input",
    "returns": "number",
    "code": "(input) => {\n    if (typeof input === 'string') {\n        return input.length;\n    }\n    if (Array.isArray(input)) {\n        return input.length;\n    }\n    if (typeof input === 'object' && input !== null) {\n        return Object.keys(input).length;\n    }\n    return 0;\n}"
  },
  {
    "type": "Function",
    "name": "$size",
    "description": "Returns the number of characters in a string, or the length of an array.",
    "args": "input",
    "returns": "number",
    "code": "(input) => {\n    if (typeof input === 'string') {\n        return input.length;\n    }\n    if (Array.isArray(input)) {\n        return input.length;\n    }\n    if (typeof input === 'object' && input !== null) {\n        return Object.keys(input).length;\n    }\n    return 0;\n}"
  },
  {
    "type": "Function",
    "name": "substring",
    "description": "Gets a substring of a string.",
    "args": "input, start, length",
    "returns": "string",
    "code": "(input, start, length) => {\n    let str = input;\n    if (typeof str !== 'string') {\n        str = JSON.stringify(str);\n    }\n    if (typeof str === 'string') {\n        let startNum = start;\n        let len = length !== null && length !== void 0 ? length : str.length;\n        if (startNum < 0) {\n            startNum = str.length + start;\n            if (startNum < 0) {\n                startNum = 0;\n            }\n        }\n        if (startNum + len > str.length) {\n            len = str.length - startNum;\n        }\n        if (len < 0) {\n            len = 0;\n        }\n        return str.substring(startNum, startNum + len);\n    }\n    return '';\n}"
  },
  {
    "type": "Function",
    "name": "$substring",
    "description": "Gets a substring of a string.",
    "args": "input, start, length",
    "returns": "string",
    "code": "(input, start, length) => {\n    let str = input;\n    if (typeof str !== 'string') {\n        str = JSON.stringify(str);\n    }\n    if (typeof str === 'string') {\n        let startNum = start;\n        let len = length !== null && length !== void 0 ? length : str.length;\n        if (startNum < 0) {\n            startNum = str.length + start;\n            if (startNum < 0) {\n                startNum = 0;\n            }\n        }\n        if (startNum + len > str.length) {\n            len = str.length - startNum;\n        }\n        if (len < 0) {\n            len = 0;\n        }\n        return str.substring(startNum, startNum + len);\n    }\n    return '';\n}"
  },
  {
    "type": "Function",
    "name": "substringBefore",
    "description": "Returns the substring before the first occurrence of the character sequence chars in str.",
    "args": "input, chars",
    "returns": "string",
    "code": "(input, chars) => {\n    const str = typeof input === 'string' ? input : JSON.stringify(input);\n    const charsStr = typeof chars === 'string' ? chars : JSON.stringify(chars);\n    const index = str.indexOf(charsStr);\n    if (index === -1) {\n        return str;\n    }\n    return str.substring(0, index);\n}"
  },
  {
    "type": "Function",
    "name": "$substringBefore",
    "description": "Returns the substring before the first occurrence of the character sequence chars in str.",
    "args": "input, chars",
    "returns": "string",
    "code": "(input, chars) => {\n    const str = typeof input === 'string' ? input : JSON.stringify(input);\n    const charsStr = typeof chars === 'string' ? chars : JSON.stringify(chars);\n    const index = str.indexOf(charsStr);\n    if (index === -1) {\n        return str;\n    }\n    return str.substring(0, index);\n}"
  },
  {
    "type": "Function",
    "name": "substringAfter",
    "description": "Returns the substring after the first occurrence of the character sequence chars in str.",
    "args": "input, chars",
    "returns": "string",
    "code": "(input, chars) => {\n    const str = typeof input === 'string' ? input : JSON.stringify(input);\n    const charsStr = typeof chars === 'string' ? chars : JSON.stringify(chars);\n    const index = str.indexOf(charsStr);\n    if (index === -1) {\n        return '';\n    }\n    return str.substring(index + charsStr.length);\n}"
  },
  {
    "type": "Function",
    "name": "$substringAfter",
    "description": "Returns the substring after the first occurrence of the character sequence chars in str.",
    "args": "input, chars",
    "returns": "string",
    "code": "(input, chars) => {\n    const str = typeof input === 'string' ? input : JSON.stringify(input);\n    const charsStr = typeof chars === 'string' ? chars : JSON.stringify(chars);\n    const index = str.indexOf(charsStr);\n    if (index === -1) {\n        return '';\n    }\n    return str.substring(index + charsStr.length);\n}"
  },
  {
    "type": "Function",
    "name": "uppercase",
    "description": "Converts the input string to uppercase.",
    "args": "input",
    "returns": "string",
    "code": "(input) => {\n    const str = typeof input === 'string' ? input : JSON.stringify(input);\n    return str.toUpperCase();\n}"
  },
  {
    "type": "Function",
    "name": "$uppercase",
    "description": "Converts the input string to uppercase.",
    "args": "input",
    "returns": "string",
    "code": "(input) => {\n    const str = typeof input === 'string' ? input : JSON.stringify(input);\n    return str.toUpperCase();\n}"
  },
  {
    "type": "Function",
    "name": "upper",
    "description": "Converts the input string to uppercase.",
    "args": "input",
    "returns": "string",
    "code": "(input) => {\n    const str = typeof input === 'string' ? input : JSON.stringify(input);\n    return str.toUpperCase();\n}"
  },
  {
    "type": "Function",
    "name": "$upper",
    "description": "Converts the input string to uppercase.",
    "args": "input",
    "returns": "string",
    "code": "(input) => {\n    const str = typeof input === 'string' ? input : JSON.stringify(input);\n    return str.toUpperCase();\n}"
  },
  {
    "type": "Function",
    "name": "lowercase",
    "description": "Converts the input string to lowercase.",
    "args": "input",
    "returns": "string",
    "code": "(input) => {\n    const str = typeof input === 'string' ? input : JSON.stringify(input);\n    return str.toLowerCase();\n}"
  },
  {
    "type": "Function",
    "name": "$lowercase",
    "description": "Converts the input string to lowercase.",
    "args": "input",
    "returns": "string",
    "code": "(input) => {\n    const str = typeof input === 'string' ? input : JSON.stringify(input);\n    return str.toLowerCase();\n}"
  },
  {
    "type": "Function",
    "name": "lower",
    "description": "Converts the input string to lowercase.",
    "args": "input",
    "returns": "string",
    "code": "(input) => {\n    const str = typeof input === 'string' ? input : JSON.stringify(input);\n    return str.toLowerCase();\n}"
  },
  {
    "type": "Function",
    "name": "$lower",
    "description": "Converts the input string to lowercase.",
    "args": "input",
    "returns": "string",
    "code": "(input) => {\n    const str = typeof input === 'string' ? input : JSON.stringify(input);\n    return str.toLowerCase();\n}"
  },
  {
    "type": "Function",
    "name": "camelCase",
    "description": "Converts the input string to camel case.",
    "args": "input",
    "returns": "string",
    "code": "(input) => {\n    if (typeof input !== 'string')\n        return '';\n    return input.split(splitRegex).map((word, index) => {\n        if (index === 0)\n            return word.toLowerCase();\n        return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();\n    }).join('');\n}"
  },
  {
    "type": "Function",
    "name": "$camelCase",
    "description": "Converts the input string to camel case.",
    "args": "input",
    "returns": "string",
    "code": "(input) => {\n    if (typeof input !== 'string')\n        return '';\n    return input.split(splitRegex).map((word, index) => {\n        if (index === 0)\n            return word.toLowerCase();\n        return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();\n    }).join('');\n}"
  },
  {
    "type": "Function",
    "name": "pascalCase",
    "description": "Converts the input string to pascal case.",
    "args": "input",
    "returns": "string",
    "code": "(input) => {\n    if (typeof input !== 'string')\n        return '';\n    return input.split(splitRegex).map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()).join('');\n}"
  },
  {
    "type": "Function",
    "name": "$pascalCase",
    "description": "Converts the input string to pascal case.",
    "args": "input",
    "returns": "string",
    "code": "(input) => {\n    if (typeof input !== 'string')\n        return '';\n    return input.split(splitRegex).map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()).join('');\n}"
  },
  {
    "type": "Function",
    "name": "trim",
    "description": "Trims whitespace from both ends of a string.",
    "args": "input",
    "returns": "string",
    "code": "(input) => {\n    if (typeof input === 'string') {\n        return input.trim();\n    }\n    return '';\n}"
  },
  {
    "type": "Function",
    "name": "$trim",
    "description": "Trims whitespace from both ends of a string.",
    "args": "input",
    "returns": "string",
    "code": "(input) => {\n    if (typeof input === 'string') {\n        return input.trim();\n    }\n    return '';\n}"
  },
  {
    "type": "Function",
    "name": "pad",
    "description": "Pads the input string on both sides to center it.",
    "args": "input, width, char",
    "returns": "string",
    "code": "(input, width, char = ' ') => {\n    const str = typeof input !== 'string' ? JSON.stringify(input) : input;\n    if (width > 0) {\n        return str.padEnd(width, char);\n    }\n    else {\n        return str.padStart(-width, char);\n    }\n}"
  },
  {
    "type": "Function",
    "name": "$pad",
    "description": "Pads the input string on both sides to center it.",
    "args": "input, width, char",
    "returns": "string",
    "code": "(input, width, char = ' ') => {\n    const str = typeof input !== 'string' ? JSON.stringify(input) : input;\n    if (width > 0) {\n        return str.padEnd(width, char);\n    }\n    else {\n        return str.padStart(-width, char);\n    }\n}"
  },
  {
    "type": "Function",
    "name": "contains",
    "description": "Checks if the input string contains the specified substring.",
    "args": "input, search",
    "returns": "boolean",
    "code": "(input, search) => {\n    if (typeof input === 'string' || Array.isArray(input)) {\n        return input.includes(search);\n    }\n    return false;\n}"
  },
  {
    "type": "Function",
    "name": "$contains",
    "description": "Checks if the input string contains the specified substring.",
    "args": "input, search",
    "returns": "boolean",
    "code": "(input, search) => {\n    if (typeof input === 'string' || Array.isArray(input)) {\n        return input.includes(search);\n    }\n    return false;\n}"
  },
  {
    "type": "Function",
    "name": "includes",
    "description": "Checks if the input string contains the specified substring.",
    "args": "input, search",
    "returns": "boolean",
    "code": "(input, search) => {\n    if (typeof input === 'string' || Array.isArray(input)) {\n        return input.includes(search);\n    }\n    return false;\n}"
  },
  {
    "type": "Function",
    "name": "$includes",
    "description": "Checks if the input string contains the specified substring.",
    "args": "input, search",
    "returns": "boolean",
    "code": "(input, search) => {\n    if (typeof input === 'string' || Array.isArray(input)) {\n        return input.includes(search);\n    }\n    return false;\n}"
  },
  {
    "type": "Function",
    "name": "split",
    "description": "Splits the input string into an array of substrings.",
    "args": "input, separator",
    "returns": "array",
    "code": "(input, separator) => {\n    if (typeof input === 'string') {\n        return input.split(separator);\n    }\n    return [];\n}"
  },
  {
    "type": "Function",
    "name": "$split",
    "description": "Splits the input string into an array of substrings.",
    "args": "input, separator",
    "returns": "array",
    "code": "(input, separator) => {\n    if (typeof input === 'string') {\n        return input.split(separator);\n    }\n    return [];\n}"
  },
  {
    "type": "Function",
    "name": "join",
    "description": "Joins elements of an array into a string.",
    "args": "input, separator",
    "returns": "string",
    "code": "(input, separator) => {\n    if (Array.isArray(input)) {\n        return input.join(separator);\n    }\n    return undefined;\n}"
  },
  {
    "type": "Function",
    "name": "$join",
    "description": "Joins elements of an array into a string.",
    "args": "input, separator",
    "returns": "string",
    "code": "(input, separator) => {\n    if (Array.isArray(input)) {\n        return input.join(separator);\n    }\n    return undefined;\n}"
  },
  {
    "type": "Function",
    "name": "replace",
    "description": "Replaces occurrences of a specified string.",
    "args": "input, search, replacement",
    "returns": "string",
    "code": "(input, search, replacement) => {\n    if (typeof input === 'string' && typeof search === 'string') {\n        const _replacement = replacement === undefined ? '' : replacement;\n        return input.replace(new RegExp(search, 'g'), _replacement);\n    }\n    return undefined;\n}"
  },
  {
    "type": "Function",
    "name": "$replace",
    "description": "Replaces occurrences of a specified string.",
    "args": "input, search, replacement",
    "returns": "string",
    "code": "(input, search, replacement) => {\n    if (typeof input === 'string' && typeof search === 'string') {\n        const _replacement = replacement === undefined ? '' : replacement;\n        return input.replace(new RegExp(search, 'g'), _replacement);\n    }\n    return undefined;\n}"
  },
  {
    "type": "Function",
    "name": "base64Encode",
    "description": "Encodes a string to Base64.",
    "args": "input",
    "returns": "string",
    "code": "(input) => {\n    if (typeof input === 'string') {\n        return Buffer.from(input).toString('base64');\n    }\n    return '';\n}"
  },
  {
    "type": "Function",
    "name": "$base64Encode",
    "description": "Encodes a string to Base64.",
    "args": "input",
    "returns": "string",
    "code": "(input) => {\n    if (typeof input === 'string') {\n        return Buffer.from(input).toString('base64');\n    }\n    return '';\n}"
  },
  {
    "type": "Function",
    "name": "base64Decode",
    "description": "Decodes a Base64 encoded string.",
    "args": "input",
    "returns": "string",
    "code": "(input) => {\n    if (typeof input === 'string') {\n        return Buffer.from(input, 'base64').toString('utf-8');\n    }\n    return '';\n}"
  },
  {
    "type": "Function",
    "name": "$base64Decode",
    "description": "Decodes a Base64 encoded string.",
    "args": "input",
    "returns": "string",
    "code": "(input) => {\n    if (typeof input === 'string') {\n        return Buffer.from(input, 'base64').toString('utf-8');\n    }\n    return '';\n}"
  },
  {
    "type": "Function",
    "name": "number",
    "description": "Converts the input to a number.",
    "args": "input",
    "returns": "number",
    "code": "(input) => {\n    if (typeof input === 'number')\n        return input;\n    if (typeof input === 'string')\n        return parseFloat(input);\n    return NaN;\n}"
  },
  {
    "type": "Function",
    "name": "$number",
    "description": "Converts the input to a number.",
    "args": "input",
    "returns": "number",
    "code": "(input) => {\n    if (typeof input === 'number')\n        return input;\n    if (typeof input === 'string')\n        return parseFloat(input);\n    return NaN;\n}"
  },
  {
    "type": "Function",
    "name": "abs",
    "description": "Returns the absolute value of a number.",
    "args": "input",
    "returns": "number",
    "code": "(input) => {\n    const num = (0, exports.toNumber)(input);\n    return isNaN(num) ? NaN : Math.abs(num);\n}"
  },
  {
    "type": "Function",
    "name": "$abs",
    "description": "Returns the absolute value of a number.",
    "args": "input",
    "returns": "number",
    "code": "(input) => {\n    const num = (0, exports.toNumber)(input);\n    return isNaN(num) ? NaN : Math.abs(num);\n}"
  },
  {
    "type": "Function",
    "name": "floor",
    "description": "Rounds a number down to the nearest integer.",
    "args": "input",
    "returns": "number",
    "code": "(input) => {\n    const num = (0, exports.toNumber)(input);\n    return isNaN(num) ? NaN : Math.floor(num);\n}"
  },
  {
    "type": "Function",
    "name": "$floor",
    "description": "Rounds a number down to the nearest integer.",
    "args": "input",
    "returns": "number",
    "code": "(input) => {\n    const num = (0, exports.toNumber)(input);\n    return isNaN(num) ? NaN : Math.floor(num);\n}"
  },
  {
    "type": "Function",
    "name": "ceil",
    "description": "Rounds a number up to the nearest integer.",
    "args": "input",
    "returns": "number",
    "code": "(input) => {\n    const num = (0, exports.toNumber)(input);\n    return isNaN(num) ? NaN : Math.ceil(num);\n}"
  },
  {
    "type": "Function",
    "name": "$ceil",
    "description": "Rounds a number up to the nearest integer.",
    "args": "input",
    "returns": "number",
    "code": "(input) => {\n    const num = (0, exports.toNumber)(input);\n    return isNaN(num) ? NaN : Math.ceil(num);\n}"
  },
  {
    "type": "Function",
    "name": "round",
    "description": "Rounds a number to the nearest integer.",
    "args": "input, decimals",
    "returns": "number",
    "code": "(input, decimals) => {\n    const num = (0, exports.toNumber)(input);\n    return isNaN(num) ? NaN : decimals ? Math.round(num * Math.pow(10, decimals)) / Math.pow(10, decimals) : Math.round(num);\n}"
  },
  {
    "type": "Function",
    "name": "$round",
    "description": "Rounds a number to the nearest integer.",
    "args": "input, decimals",
    "returns": "number",
    "code": "(input, decimals) => {\n    const num = (0, exports.toNumber)(input);\n    return isNaN(num) ? NaN : decimals ? Math.round(num * Math.pow(10, decimals)) / Math.pow(10, decimals) : Math.round(num);\n}"
  },
  {
    "type": "Function",
    "name": "power",
    "description": "Returns the value of a number raised to a power.",
    "args": "input, exponent",
    "returns": "number",
    "code": "(input, exponent) => {\n    const num = (0, exports.toNumber)(input);\n    const exp = exponent === undefined ? 2 : exponent;\n    return isNaN(num) ? NaN : Math.pow(num, exp);\n}"
  },
  {
    "type": "Function",
    "name": "$power",
    "description": "Returns the value of a number raised to a power.",
    "args": "input, exponent",
    "returns": "number",
    "code": "(input, exponent) => {\n    const num = (0, exports.toNumber)(input);\n    const exp = exponent === undefined ? 2 : exponent;\n    return isNaN(num) ? NaN : Math.pow(num, exp);\n}"
  },
  {
    "type": "Function",
    "name": "sqrt",
    "description": "Returns the square root of a number.",
    "args": "input",
    "returns": "number",
    "code": "(input) => {\n    const num = (0, exports.toNumber)(input);\n    return isNaN(num) ? NaN : Math.sqrt(num);\n}"
  },
  {
    "type": "Function",
    "name": "$sqrt",
    "description": "Returns the square root of a number.",
    "args": "input",
    "returns": "number",
    "code": "(input) => {\n    const num = (0, exports.toNumber)(input);\n    return isNaN(num) ? NaN : Math.sqrt(num);\n}"
  },
  {
    "type": "Function",
    "name": "random",
    "description": "Generates a random number between 0 (inclusive) and 1 (exclusive).",
    "returns": "number",
    "code": "() => {\n    return Math.random();\n}"
  },
  {
    "type": "Function",
    "name": "$random",
    "description": "Generates a random number between 0 (inclusive) and 1 (exclusive).",
    "returns": "number",
    "code": "() => {\n    return Math.random();\n}"
  },
  {
    "type": "Function",
    "name": "formatNumber",
    "description": "Casts the number to a string and formats it to a decimal representation as specified by the format string.",
    "args": "input, format",
    "returns": "string",
    "code": "(input, format) => {\n    var _a, _b, _c;\n    const num = typeof input === 'number' ? input : parseInt((0, exports.toNumber)(input).toString(), 10);\n    return isNaN(num) ? '' : num.toLocaleString('en-us', {\n        minimumFractionDigits: (_a = format.split('.')[1]) === null || _a === void 0 ? void 0 : _a.length,\n        maximumFractionDigits: (_b = format.split('.')[1]) === null || _b === void 0 ? void 0 : _b.length,\n        useGrouping: (_c = format.split('.')[0]) === null || _c === void 0 ? void 0 : _c.includes(',')\n    });\n}"
  },
  {
    "type": "Function",
    "name": "$formatNumber",
    "description": "Casts the number to a string and formats it to a decimal representation as specified by the format string.",
    "args": "input, format",
    "returns": "string",
    "code": "(input, format) => {\n    var _a, _b, _c;\n    const num = typeof input === 'number' ? input : parseInt((0, exports.toNumber)(input).toString(), 10);\n    return isNaN(num) ? '' : num.toLocaleString('en-us', {\n        minimumFractionDigits: (_a = format.split('.')[1]) === null || _a === void 0 ? void 0 : _a.length,\n        maximumFractionDigits: (_b = format.split('.')[1]) === null || _b === void 0 ? void 0 : _b.length,\n        useGrouping: (_c = format.split('.')[0]) === null || _c === void 0 ? void 0 : _c.includes(',')\n    });\n}"
  },
  {
    "type": "Function",
    "name": "formatBase",
    "description": "Formats a number as a string in the specified base.",
    "args": "input, base",
    "returns": "string",
    "code": "(input, base) => {\n    const num = typeof input === 'number' ? input : parseInt((0, exports.toNumber)(input).toString(), 10);\n    return isNaN(num) ? '' : num.toString(base);\n}"
  },
  {
    "type": "Function",
    "name": "$formatBase",
    "description": "Formats a number as a string in the specified base.",
    "args": "input, base",
    "returns": "string",
    "code": "(input, base) => {\n    const num = typeof input === 'number' ? input : parseInt((0, exports.toNumber)(input).toString(), 10);\n    return isNaN(num) ? '' : num.toString(base);\n}"
  },
  {
    "type": "Function",
    "name": "formatInteger",
    "description": "Formats a number as an integer.",
    "args": "input, format",
    "returns": "string",
    "code": "(input, format) => {\n    const num = (0, exports.toNumber)(input);\n    return isNaN(num) ? '' : (0, exports.pad)(Math.floor(num).toString(), -format.length, '0');\n}"
  },
  {
    "type": "Function",
    "name": "$formatInteger",
    "description": "Formats a number as an integer.",
    "args": "input, format",
    "returns": "string",
    "code": "(input, format) => {\n    const num = (0, exports.toNumber)(input);\n    return isNaN(num) ? '' : (0, exports.pad)(Math.floor(num).toString(), -format.length, '0');\n}"
  },
  {
    "type": "Function",
    "name": "parseInteger",
    "description": "Parses a string and returns an integer.",
    "args": "input",
    "returns": "number",
    "code": "(input) => {\n    if (typeof input === 'string') {\n        return parseInt(input, 10);\n    }\n    else if (typeof input === 'number') {\n        return Math.floor(input);\n    }\n    return NaN;\n}"
  },
  {
    "type": "Function",
    "name": "parseInt",
    "description": "Parses a string and returns an integer.",
    "args": "input",
    "returns": "number",
    "code": "(input) => {\n    if (typeof input === 'string') {\n        return parseInt(input, 10);\n    }\n    else if (typeof input === 'number') {\n        return Math.floor(input);\n    }\n    return NaN;\n}"
  },
  {
    "type": "Function",
    "name": "$parseInteger",
    "description": "Parses a string and returns an integer.",
    "args": "input",
    "returns": "number",
    "code": "(input) => {\n    if (typeof input === 'string') {\n        return parseInt(input, 10);\n    }\n    else if (typeof input === 'number') {\n        return Math.floor(input);\n    }\n    return NaN;\n}"
  },
  {
    "type": "Function",
    "name": "sum",
    "description": "Calculates the sum of an array of numbers.",
    "args": "input",
    "returns": "number",
    "code": "(...input) => {\n    if (!Array.isArray(input))\n        return NaN;\n    return input.flat().reduce((acc, val) => acc + (0, exports.toNumber)(val), 0);\n}"
  },
  {
    "type": "Function",
    "name": "$sum",
    "description": "Calculates the sum of an array of numbers.",
    "args": "input",
    "returns": "number",
    "code": "(...input) => {\n    if (!Array.isArray(input))\n        return NaN;\n    return input.flat().reduce((acc, val) => acc + (0, exports.toNumber)(val), 0);\n}"
  },
  {
    "type": "Function",
    "name": "max",
    "description": "Finds the maximum value in an array of numbers.",
    "args": "input",
    "returns": "number",
    "code": "(...input) => {\n    if (!Array.isArray(input))\n        return NaN;\n    return Math.max(...input.flat().map(exports.toNumber));\n}"
  },
  {
    "type": "Function",
    "name": "$max",
    "description": "Finds the maximum value in an array of numbers.",
    "args": "input",
    "returns": "number",
    "code": "(...input) => {\n    if (!Array.isArray(input))\n        return NaN;\n    return Math.max(...input.flat().map(exports.toNumber));\n}"
  },
  {
    "type": "Function",
    "name": "min",
    "description": "Finds the minimum value in an array of numbers.",
    "args": "input",
    "returns": "number",
    "code": "(...input) => {\n    if (!Array.isArray(input))\n        return NaN;\n    return Math.min(...input.flat().map(exports.toNumber));\n}"
  },
  {
    "type": "Function",
    "name": "$min",
    "description": "Finds the minimum value in an array of numbers.",
    "args": "input",
    "returns": "number",
    "code": "(...input) => {\n    if (!Array.isArray(input))\n        return NaN;\n    return Math.min(...input.flat().map(exports.toNumber));\n}"
  },
  {
    "type": "Function",
    "name": "average",
    "description": "Calculates the average of an array of numbers.",
    "args": "input",
    "returns": "number",
    "code": "(...input) => {\n    if (!Array.isArray(input))\n        return NaN;\n    const total = (0, exports.sum)(...input);\n    return total / input.flat().length;\n}"
  },
  {
    "type": "Function",
    "name": "avg",
    "description": "Calculates the average of an array of numbers.",
    "args": "input",
    "returns": "number",
    "code": "(...input) => {\n    if (!Array.isArray(input))\n        return NaN;\n    const total = (0, exports.sum)(...input);\n    return total / input.flat().length;\n}"
  },
  {
    "type": "Function",
    "name": "$average",
    "description": "Calculates the average of an array of numbers.",
    "args": "input",
    "returns": "number",
    "code": "(...input) => {\n    if (!Array.isArray(input))\n        return NaN;\n    const total = (0, exports.sum)(...input);\n    return total / input.flat().length;\n}"
  },
  {
    "type": "Function",
    "name": "boolean",
    "description": "Converts the input to a boolean.",
    "args": "input",
    "returns": "boolean",
    "code": "(input) => {\n    if (typeof input === 'boolean')\n        return input;\n    if (typeof input === 'number')\n        return input !== 0;\n    if (typeof input === 'string') {\n        if (input.trim().toLowerCase() === 'true' || input.trim() === '1')\n            return true;\n        if (input.trim().toLowerCase() === 'false' || input.trim() === '0')\n            return false;\n        else\n            return undefined;\n    }\n    return Boolean(input);\n}"
  },
  {
    "type": "Function",
    "name": "$boolean",
    "description": "Converts the input to a boolean.",
    "args": "input",
    "returns": "boolean",
    "code": "(input) => {\n    if (typeof input === 'boolean')\n        return input;\n    if (typeof input === 'number')\n        return input !== 0;\n    if (typeof input === 'string') {\n        if (input.trim().toLowerCase() === 'true' || input.trim() === '1')\n            return true;\n        if (input.trim().toLowerCase() === 'false' || input.trim() === '0')\n            return false;\n        else\n            return undefined;\n    }\n    return Boolean(input);\n}"
  },
  {
    "type": "Function",
    "name": "bool",
    "description": "Converts the input to a boolean.",
    "args": "input",
    "returns": "boolean",
    "code": "(input) => {\n    if (typeof input === 'boolean')\n        return input;\n    if (typeof input === 'number')\n        return input !== 0;\n    if (typeof input === 'string') {\n        if (input.trim().toLowerCase() === 'true' || input.trim() === '1')\n            return true;\n        if (input.trim().toLowerCase() === 'false' || input.trim() === '0')\n            return false;\n        else\n            return undefined;\n    }\n    return Boolean(input);\n}"
  },
  {
    "type": "Function",
    "name": "$bool",
    "description": "Converts the input to a boolean.",
    "args": "input",
    "returns": "boolean",
    "code": "(input) => {\n    if (typeof input === 'boolean')\n        return input;\n    if (typeof input === 'number')\n        return input !== 0;\n    if (typeof input === 'string') {\n        if (input.trim().toLowerCase() === 'true' || input.trim() === '1')\n            return true;\n        if (input.trim().toLowerCase() === 'false' || input.trim() === '0')\n            return false;\n        else\n            return undefined;\n    }\n    return Boolean(input);\n}"
  },
  {
    "type": "Function",
    "name": "not",
    "description": "Returns the logical NOT of the input.",
    "args": "input",
    "returns": "boolean",
    "code": "(input) => {\n    return !(0, exports.toBoolean)(input);\n}"
  },
  {
    "type": "Function",
    "name": "$not",
    "description": "Returns the logical NOT of the input.",
    "args": "input",
    "returns": "boolean",
    "code": "(input) => {\n    return !(0, exports.toBoolean)(input);\n}"
  },
  {
    "type": "Function",
    "name": "append",
    "description": "Appends an element to an array.",
    "args": "input",
    "returns": "array",
    "code": "(...input) => {\n    if (!Array.isArray(input))\n        return [];\n    return [...input.flat()];\n}"
  },
  {
    "type": "Function",
    "name": "$append",
    "description": "Appends an element to an array.",
    "args": "input",
    "returns": "array",
    "code": "(...input) => {\n    if (!Array.isArray(input))\n        return [];\n    return [...input.flat()];\n}"
  },
  {
    "type": "Function",
    "name": "concat",
    "description": "Appends an element to an array.",
    "args": "input",
    "returns": "array",
    "code": "(...input) => {\n    if (!Array.isArray(input))\n        return [];\n    return [...input.flat()];\n}"
  },
  {
    "type": "Function",
    "name": "$concat",
    "description": "Appends an element to an array.",
    "args": "input",
    "returns": "array",
    "code": "(...input) => {\n    if (!Array.isArray(input))\n        return [];\n    return [...input.flat()];\n}"
  },
  {
    "type": "Function",
    "name": "reverse",
    "description": "Reverses the elements of an array.",
    "args": "input",
    "returns": "array",
    "code": "(...input) => {\n    if (!Array.isArray(input))\n        return [];\n    return [...input.flat()].reverse();\n}"
  },
  {
    "type": "Function",
    "name": "$reverse",
    "description": "Reverses the elements of an array.",
    "args": "input",
    "returns": "array",
    "code": "(...input) => {\n    if (!Array.isArray(input))\n        return [];\n    return [...input.flat()].reverse();\n}"
  },
  {
    "type": "Function",
    "name": "shuffle",
    "description": "Shuffles the elements of an array.",
    "args": "input",
    "returns": "array",
    "code": "(input) => {\n    if (!Array.isArray(input))\n        return [];\n    for (let i = input.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * (i + 1));\n        [input[i], input[j]] = [input[j], input[i]];\n    }\n    return input;\n}"
  },
  {
    "type": "Function",
    "name": "$shuffle",
    "description": "Shuffles the elements of an array.",
    "args": "input",
    "returns": "array",
    "code": "(input) => {\n    if (!Array.isArray(input))\n        return [];\n    for (let i = input.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * (i + 1));\n        [input[i], input[j]] = [input[j], input[i]];\n    }\n    return input;\n}"
  },
  {
    "type": "Function",
    "name": "sort",
    "description": "Sorts the elements of an array.",
    "args": "input, expression, descending",
    "returns": "array",
    "code": "(input, expression, descending) => {\n    if (!Array.isArray(input))\n        return [];\n    if (!expression)\n        return [...input].sort();\n    const expr = _1.default.compile(expression);\n    const compareFunction = (a, b) => {\n        const aValue = expr.evalSync(a);\n        const bValue = expr.evalSync(b);\n        if (aValue < bValue)\n            return descending ? -1 : 1;\n        if (aValue > bValue)\n            return descending ? 1 : -1;\n        return 0;\n    };\n    return [...input].sort(compareFunction);\n}"
  },
  {
    "type": "Function",
    "name": "$sort",
    "description": "Sorts the elements of an array.",
    "args": "input, expression, descending",
    "returns": "array",
    "code": "(input, expression, descending) => {\n    if (!Array.isArray(input))\n        return [];\n    if (!expression)\n        return [...input].sort();\n    const expr = _1.default.compile(expression);\n    const compareFunction = (a, b) => {\n        const aValue = expr.evalSync(a);\n        const bValue = expr.evalSync(b);\n        if (aValue < bValue)\n            return descending ? -1 : 1;\n        if (aValue > bValue)\n            return descending ? 1 : -1;\n        return 0;\n    };\n    return [...input].sort(compareFunction);\n}"
  },
  {
    "type": "Function",
    "name": "order",
    "description": "Sorts the elements of an array.",
    "args": "input, expression, descending",
    "returns": "array",
    "code": "(input, expression, descending) => {\n    if (!Array.isArray(input))\n        return [];\n    if (!expression)\n        return [...input].sort();\n    const expr = _1.default.compile(expression);\n    const compareFunction = (a, b) => {\n        const aValue = expr.evalSync(a);\n        const bValue = expr.evalSync(b);\n        if (aValue < bValue)\n            return descending ? -1 : 1;\n        if (aValue > bValue)\n            return descending ? 1 : -1;\n        return 0;\n    };\n    return [...input].sort(compareFunction);\n}"
  },
  {
    "type": "Function",
    "name": "$order",
    "description": "Sorts the elements of an array.",
    "args": "input, expression, descending",
    "returns": "array",
    "code": "(input, expression, descending) => {\n    if (!Array.isArray(input))\n        return [];\n    if (!expression)\n        return [...input].sort();\n    const expr = _1.default.compile(expression);\n    const compareFunction = (a, b) => {\n        const aValue = expr.evalSync(a);\n        const bValue = expr.evalSync(b);\n        if (aValue < bValue)\n            return descending ? -1 : 1;\n        if (aValue > bValue)\n            return descending ? 1 : -1;\n        return 0;\n    };\n    return [...input].sort(compareFunction);\n}"
  },
  {
    "type": "Function",
    "name": "distinct",
    "description": "Returns a new array with the elements of the input array with duplicates removed.",
    "args": "input",
    "returns": "array",
    "code": "(input) => {\n    if (!Array.isArray(input))\n        return [];\n    return [...new Set(input)];\n}"
  },
  {
    "type": "Function",
    "name": "$distinct",
    "description": "Returns a new array with the elements of the input array with duplicates removed.",
    "args": "input",
    "returns": "array",
    "code": "(input) => {\n    if (!Array.isArray(input))\n        return [];\n    return [...new Set(input)];\n}"
  },
  {
    "type": "Function",
    "name": "toObject",
    "description": "Create a new object based on an array of key-value pairs.",
    "args": "input, val",
    "returns": "any",
    "code": "(input, val) => {\n    if (typeof input === 'string')\n        return { [input]: val };\n    if (!Array.isArray(input))\n        return {};\n    return input.reduce((acc, kv) => {\n        if (Array.isArray(kv) && kv.length === 2) {\n            acc[kv[0]] = kv[1];\n            return acc;\n        }\n        else if (typeof kv === 'string') {\n            acc[kv] = val;\n            return acc;\n        }\n        return acc;\n    }, {});\n}"
  },
  {
    "type": "Function",
    "name": "$toObject",
    "description": "Create a new object based on an array of key-value pairs.",
    "args": "input, val",
    "returns": "any",
    "code": "(input, val) => {\n    if (typeof input === 'string')\n        return { [input]: val };\n    if (!Array.isArray(input))\n        return {};\n    return input.reduce((acc, kv) => {\n        if (Array.isArray(kv) && kv.length === 2) {\n            acc[kv[0]] = kv[1];\n            return acc;\n        }\n        else if (typeof kv === 'string') {\n            acc[kv] = val;\n            return acc;\n        }\n        return acc;\n    }, {});\n}"
  },
  {
    "type": "Function",
    "name": "fromEntries",
    "description": "Create a new object based on an array of key-value pairs.",
    "args": "input, val",
    "returns": "any",
    "code": "(input, val) => {\n    if (typeof input === 'string')\n        return { [input]: val };\n    if (!Array.isArray(input))\n        return {};\n    return input.reduce((acc, kv) => {\n        if (Array.isArray(kv) && kv.length === 2) {\n            acc[kv[0]] = kv[1];\n            return acc;\n        }\n        else if (typeof kv === 'string') {\n            acc[kv] = val;\n            return acc;\n        }\n        return acc;\n    }, {});\n}"
  },
  {
    "type": "Function",
    "name": "$fromEntries",
    "description": "Create a new object based on an array of key-value pairs.",
    "args": "input, val",
    "returns": "any",
    "code": "(input, val) => {\n    if (typeof input === 'string')\n        return { [input]: val };\n    if (!Array.isArray(input))\n        return {};\n    return input.reduce((acc, kv) => {\n        if (Array.isArray(kv) && kv.length === 2) {\n            acc[kv[0]] = kv[1];\n            return acc;\n        }\n        else if (typeof kv === 'string') {\n            acc[kv] = val;\n            return acc;\n        }\n        return acc;\n    }, {});\n}"
  },
  {
    "type": "Function",
    "name": "mapField",
    "description": "Returns a new array with the elements of the input array transformed by the specified map function.",
    "args": "input, field",
    "returns": "array",
    "code": "(input, field) => {\n    if (!Array.isArray(input))\n        return [];\n    return input.map(item => item[field]);\n}"
  },
  {
    "type": "Function",
    "name": "$mapField",
    "description": "Returns a new array with the elements of the input array transformed by the specified map function.",
    "args": "input, field",
    "returns": "array",
    "code": "(input, field) => {\n    if (!Array.isArray(input))\n        return [];\n    return input.map(item => item[field]);\n}"
  },
  {
    "type": "Function",
    "name": "map",
    "description": "Returns an array containing the results of applying the expression parameter to each value in the array parameter.\r\nThe expression must be a valid JEXL expression string, which is applied to each element of the array.\r\nThe relative context provided to the expression is an object with the properties value, index and array (the original array).",
    "args": "input, expression",
    "returns": "array",
    "code": "(input, expression) => {\n    if (!Array.isArray(input))\n        return undefined;\n    const expr = _1.default.compile(expression);\n    return input.map((value, index, array) => {\n        return expr.evalSync({ value, index, array });\n    });\n}"
  },
  {
    "type": "Function",
    "name": "$map",
    "description": "Returns an array containing the results of applying the expression parameter to each value in the array parameter.\r\nThe expression must be a valid JEXL expression string, which is applied to each element of the array.\r\nThe relative context provided to the expression is an object with the properties value, index and array (the original array).",
    "args": "input, expression",
    "returns": "array",
    "code": "(input, expression) => {\n    if (!Array.isArray(input))\n        return undefined;\n    const expr = _1.default.compile(expression);\n    return input.map((value, index, array) => {\n        return expr.evalSync({ value, index, array });\n    });\n}"
  },
  {
    "type": "Function",
    "name": "any",
    "description": "Checks whether the provided array has any elements that match the specified expression.\r\nThe expression must be a valid JEXL expression string, and is applied to each element of the array.\r\nThe relative context provided to the expression is an object with the properties value and array (the original array).",
    "args": "input, expression",
    "returns": "boolean",
    "code": "(input, expression) => {\n    if (!Array.isArray(input))\n        return false;\n    const expr = _1.default.compile(expression);\n    return input.some((value, index, array) => {\n        return expr.evalSync({ value, index, array });\n    });\n}"
  },
  {
    "type": "Function",
    "name": "$any",
    "description": "Checks whether the provided array has any elements that match the specified expression.\r\nThe expression must be a valid JEXL expression string, and is applied to each element of the array.\r\nThe relative context provided to the expression is an object with the properties value and array (the original array).",
    "args": "input, expression",
    "returns": "boolean",
    "code": "(input, expression) => {\n    if (!Array.isArray(input))\n        return false;\n    const expr = _1.default.compile(expression);\n    return input.some((value, index, array) => {\n        return expr.evalSync({ value, index, array });\n    });\n}"
  },
  {
    "type": "Function",
    "name": "some",
    "description": "Checks whether the provided array has any elements that match the specified expression.\r\nThe expression must be a valid JEXL expression string, and is applied to each element of the array.\r\nThe relative context provided to the expression is an object with the properties value and array (the original array).",
    "args": "input, expression",
    "returns": "boolean",
    "code": "(input, expression) => {\n    if (!Array.isArray(input))\n        return false;\n    const expr = _1.default.compile(expression);\n    return input.some((value, index, array) => {\n        return expr.evalSync({ value, index, array });\n    });\n}"
  },
  {
    "type": "Function",
    "name": "$some",
    "description": "Checks whether the provided array has any elements that match the specified expression.\r\nThe expression must be a valid JEXL expression string, and is applied to each element of the array.\r\nThe relative context provided to the expression is an object with the properties value and array (the original array).",
    "args": "input, expression",
    "returns": "boolean",
    "code": "(input, expression) => {\n    if (!Array.isArray(input))\n        return false;\n    const expr = _1.default.compile(expression);\n    return input.some((value, index, array) => {\n        return expr.evalSync({ value, index, array });\n    });\n}"
  },
  {
    "type": "Function",
    "name": "all",
    "description": "Checks whether the provided array has all elements that match the specified expression.\r\nThe expression must be a valid JEXL expression string, and is applied to each element of the array.\r\nThe relative context provided to the expression is an object with the properties value and array (the original array).",
    "args": "input, expression",
    "returns": "boolean",
    "code": "(input, expression) => {\n    if (!Array.isArray(input))\n        return false;\n    const expr = _1.default.compile(expression);\n    return input.every((value, index, array) => {\n        return expr.evalSync({ value, index, array });\n    });\n}"
  },
  {
    "type": "Function",
    "name": "$all",
    "description": "Checks whether the provided array has all elements that match the specified expression.\r\nThe expression must be a valid JEXL expression string, and is applied to each element of the array.\r\nThe relative context provided to the expression is an object with the properties value and array (the original array).",
    "args": "input, expression",
    "returns": "boolean",
    "code": "(input, expression) => {\n    if (!Array.isArray(input))\n        return false;\n    const expr = _1.default.compile(expression);\n    return input.every((value, index, array) => {\n        return expr.evalSync({ value, index, array });\n    });\n}"
  },
  {
    "type": "Function",
    "name": "every",
    "description": "Checks whether the provided array has all elements that match the specified expression.\r\nThe expression must be a valid JEXL expression string, and is applied to each element of the array.\r\nThe relative context provided to the expression is an object with the properties value and array (the original array).",
    "args": "input, expression",
    "returns": "boolean",
    "code": "(input, expression) => {\n    if (!Array.isArray(input))\n        return false;\n    const expr = _1.default.compile(expression);\n    return input.every((value, index, array) => {\n        return expr.evalSync({ value, index, array });\n    });\n}"
  },
  {
    "type": "Function",
    "name": "$every",
    "description": "Checks whether the provided array has all elements that match the specified expression.\r\nThe expression must be a valid JEXL expression string, and is applied to each element of the array.\r\nThe relative context provided to the expression is an object with the properties value and array (the original array).",
    "args": "input, expression",
    "returns": "boolean",
    "code": "(input, expression) => {\n    if (!Array.isArray(input))\n        return false;\n    const expr = _1.default.compile(expression);\n    return input.every((value, index, array) => {\n        return expr.evalSync({ value, index, array });\n    });\n}"
  },
  {
    "type": "Function",
    "name": "filter",
    "description": "Returns a new array with the elements of the input array that match the specified expression.\r\nThe expression must be a valid JEXL expression string, and is applied to each element of the array.\r\nThe relative context provided to the expression is an object with the properties value and array (the original array).",
    "args": "input, expression",
    "returns": "array",
    "code": "(input, expression) => {\n    if (!Array.isArray(input))\n        return [];\n    const expr = _1.default.compile(expression);\n    return input.filter((value, index, array) => {\n        return expr.evalSync({ value, index, array });\n    });\n}"
  },
  {
    "type": "Function",
    "name": "$filter",
    "description": "Returns a new array with the elements of the input array that match the specified expression.\r\nThe expression must be a valid JEXL expression string, and is applied to each element of the array.\r\nThe relative context provided to the expression is an object with the properties value and array (the original array).",
    "args": "input, expression",
    "returns": "array",
    "code": "(input, expression) => {\n    if (!Array.isArray(input))\n        return [];\n    const expr = _1.default.compile(expression);\n    return input.filter((value, index, array) => {\n        return expr.evalSync({ value, index, array });\n    });\n}"
  },
  {
    "type": "Function",
    "name": "find",
    "description": "Finds the first element in an array that matches the specified expression.\r\nThe expression must be a valid JEXL expression string, and is applied to each element of the array.\r\nThe relative context provided to the expression is an object with the properties value and array (the original array).",
    "args": "input, expression",
    "returns": "unknown",
    "code": "(input, expression) => {\n    if (!Array.isArray(input))\n        return undefined;\n    const expr = _1.default.compile(expression);\n    return input.find((value, index, array) => {\n        return expr.evalSync({ value, index, array });\n    });\n}"
  },
  {
    "type": "Function",
    "name": "$find",
    "description": "Finds the first element in an array that matches the specified expression.\r\nThe expression must be a valid JEXL expression string, and is applied to each element of the array.\r\nThe relative context provided to the expression is an object with the properties value and array (the original array).",
    "args": "input, expression",
    "returns": "unknown",
    "code": "(input, expression) => {\n    if (!Array.isArray(input))\n        return undefined;\n    const expr = _1.default.compile(expression);\n    return input.find((value, index, array) => {\n        return expr.evalSync({ value, index, array });\n    });\n}"
  },
  {
    "type": "Function",
    "name": "reduce",
    "description": "Returns an aggregated value derived from applying the function parameter successively to each value in array in combination with the result of the previous application of the function.\r\nThe expression must be a valid JEXL expression string, and behaves like an infix operator between each value within the array.\r\nThe relative context provided to the expression is an object with the properties accumulator, value, index and array (the original array).",
    "args": "input, expression, initialValue",
    "returns": "unknown",
    "code": "(input, expression, initialValue) => {\n    if (!Array.isArray(input))\n        return undefined;\n    const expr = _1.default.compile(expression);\n    return input.reduce((accumulator, value, index, array) => {\n        return expr.evalSync({ accumulator, value, index, array });\n    }, initialValue);\n}"
  },
  {
    "type": "Function",
    "name": "$reduce",
    "description": "Returns an aggregated value derived from applying the function parameter successively to each value in array in combination with the result of the previous application of the function.\r\nThe expression must be a valid JEXL expression string, and behaves like an infix operator between each value within the array.\r\nThe relative context provided to the expression is an object with the properties accumulator, value, index and array (the original array).",
    "args": "input, expression, initialValue",
    "returns": "unknown",
    "code": "(input, expression, initialValue) => {\n    if (!Array.isArray(input))\n        return undefined;\n    const expr = _1.default.compile(expression);\n    return input.reduce((accumulator, value, index, array) => {\n        return expr.evalSync({ accumulator, value, index, array });\n    }, initialValue);\n}"
  },
  {
    "type": "Function",
    "name": "keys",
    "description": "Returns the keys of an object.",
    "args": "input",
    "returns": "array",
    "code": "(input) => {\n    if (typeof input === 'object' && input !== null) {\n        return Object.keys(input);\n    }\n    return undefined;\n}"
  },
  {
    "type": "Function",
    "name": "$keys",
    "description": "Returns the keys of an object.",
    "args": "input",
    "returns": "array",
    "code": "(input) => {\n    if (typeof input === 'object' && input !== null) {\n        return Object.keys(input);\n    }\n    return undefined;\n}"
  },
  {
    "type": "Function",
    "name": "values",
    "description": "Returns the values of an object.",
    "args": "input",
    "returns": "array",
    "code": "(input) => {\n    if (typeof input === 'object' && input !== null) {\n        return Object.values(input);\n    }\n    return undefined;\n}"
  },
  {
    "type": "Function",
    "name": "$values",
    "description": "Returns the values of an object.",
    "args": "input",
    "returns": "array",
    "code": "(input) => {\n    if (typeof input === 'object' && input !== null) {\n        return Object.values(input);\n    }\n    return undefined;\n}"
  },
  {
    "type": "Function",
    "name": "entries",
    "description": "Returns an array of key-value pairs from the input object.",
    "args": "input",
    "returns": "array",
    "code": "(input) => {\n    if (typeof input === 'object' && input !== null) {\n        return Object.entries(input);\n    }\n    return undefined;\n}"
  },
  {
    "type": "Function",
    "name": "$entries",
    "description": "Returns an array of key-value pairs from the input object.",
    "args": "input",
    "returns": "array",
    "code": "(input) => {\n    if (typeof input === 'object' && input !== null) {\n        return Object.entries(input);\n    }\n    return undefined;\n}"
  },
  {
    "type": "Function",
    "name": "merge",
    "description": "Returns a new object with the properties of the input objects merged together.",
    "args": "args",
    "returns": "Record",
    "code": "(...args) => {\n    return args.reduce((acc, obj) => {\n        if (typeof obj === 'object' && obj !== null) {\n            return { ...acc, ...obj };\n        }\n        return acc;\n    }, {});\n}"
  },
  {
    "type": "Function",
    "name": "$merge",
    "description": "Returns a new object with the properties of the input objects merged together.",
    "args": "args",
    "returns": "Record",
    "code": "(...args) => {\n    return args.reduce((acc, obj) => {\n        if (typeof obj === 'object' && obj !== null) {\n            return { ...acc, ...obj };\n        }\n        return acc;\n    }, {});\n}"
  },
  {
    "type": "Function",
    "name": "now",
    "description": "Returns the current date and time in the ISO 8601 format.",
    "returns": "string",
    "code": "() => {\n    return new Date().toISOString();\n}"
  },
  {
    "type": "Function",
    "name": "$now",
    "description": "Returns the current date and time in the ISO 8601 format.",
    "returns": "string",
    "code": "() => {\n    return new Date().toISOString();\n}"
  },
  {
    "type": "Function",
    "name": "millis",
    "description": "Returns the current date and time in milliseconds since the Unix epoch.",
    "returns": "number",
    "code": "() => {\n    return Date.now();\n}"
  },
  {
    "type": "Function",
    "name": "$millis",
    "description": "Returns the current date and time in milliseconds since the Unix epoch.",
    "returns": "number",
    "code": "() => {\n    return Date.now();\n}"
  },
  {
    "type": "Function",
    "name": "millisToDateTime",
    "description": "Parses the number of milliseconds since the Unix epoch or parses a string (with or without specified format) and returns the date and time in the ISO 8601 format.",
    "args": "input, format",
    "returns": "string",
    "code": "(input, format) => {\n    if (typeof input === 'number') {\n        return new Date(input).toISOString();\n    }\n    if (typeof input === 'string') {\n        if (format) {\n            // Add UTC as timezone if not provided\n            const _format = (format.includes('x') || format.includes('X')) ? format : `${format} X`;\n            const _input = (format.includes('x') || format.includes('X')) ? input : `${input} Z`;\n            return (0, date_fns_1.parse)(_input, _format, new Date()).toISOString();\n        }\n        return new Date(input).toISOString();\n    }\n    if (input === undefined) {\n        return new Date().toISOString();\n    }\n    return undefined;\n}"
  },
  {
    "type": "Function",
    "name": "$millisToDateTime",
    "description": "Parses the number of milliseconds since the Unix epoch or parses a string (with or without specified format) and returns the date and time in the ISO 8601 format.",
    "args": "input, format",
    "returns": "string",
    "code": "(input, format) => {\n    if (typeof input === 'number') {\n        return new Date(input).toISOString();\n    }\n    if (typeof input === 'string') {\n        if (format) {\n            // Add UTC as timezone if not provided\n            const _format = (format.includes('x') || format.includes('X')) ? format : `${format} X`;\n            const _input = (format.includes('x') || format.includes('X')) ? input : `${input} Z`;\n            return (0, date_fns_1.parse)(_input, _format, new Date()).toISOString();\n        }\n        return new Date(input).toISOString();\n    }\n    if (input === undefined) {\n        return new Date().toISOString();\n    }\n    return undefined;\n}"
  },
  {
    "type": "Function",
    "name": "fromMillis",
    "description": "Parses the number of milliseconds since the Unix epoch or parses a string (with or without specified format) and returns the date and time in the ISO 8601 format.",
    "args": "input, format",
    "returns": "string",
    "code": "(input, format) => {\n    if (typeof input === 'number') {\n        return new Date(input).toISOString();\n    }\n    if (typeof input === 'string') {\n        if (format) {\n            // Add UTC as timezone if not provided\n            const _format = (format.includes('x') || format.includes('X')) ? format : `${format} X`;\n            const _input = (format.includes('x') || format.includes('X')) ? input : `${input} Z`;\n            return (0, date_fns_1.parse)(_input, _format, new Date()).toISOString();\n        }\n        return new Date(input).toISOString();\n    }\n    if (input === undefined) {\n        return new Date().toISOString();\n    }\n    return undefined;\n}"
  },
  {
    "type": "Function",
    "name": "$fromMillis",
    "description": "Parses the number of milliseconds since the Unix epoch or parses a string (with or without specified format) and returns the date and time in the ISO 8601 format.",
    "args": "input, format",
    "returns": "string",
    "code": "(input, format) => {\n    if (typeof input === 'number') {\n        return new Date(input).toISOString();\n    }\n    if (typeof input === 'string') {\n        if (format) {\n            // Add UTC as timezone if not provided\n            const _format = (format.includes('x') || format.includes('X')) ? format : `${format} X`;\n            const _input = (format.includes('x') || format.includes('X')) ? input : `${input} Z`;\n            return (0, date_fns_1.parse)(_input, _format, new Date()).toISOString();\n        }\n        return new Date(input).toISOString();\n    }\n    if (input === undefined) {\n        return new Date().toISOString();\n    }\n    return undefined;\n}"
  },
  {
    "type": "Function",
    "name": "toDateTime",
    "description": "Parses the number of milliseconds since the Unix epoch or parses a string (with or without specified format) and returns the date and time in the ISO 8601 format.",
    "args": "input, format",
    "returns": "string",
    "code": "(input, format) => {\n    if (typeof input === 'number') {\n        return new Date(input).toISOString();\n    }\n    if (typeof input === 'string') {\n        if (format) {\n            // Add UTC as timezone if not provided\n            const _format = (format.includes('x') || format.includes('X')) ? format : `${format} X`;\n            const _input = (format.includes('x') || format.includes('X')) ? input : `${input} Z`;\n            return (0, date_fns_1.parse)(_input, _format, new Date()).toISOString();\n        }\n        return new Date(input).toISOString();\n    }\n    if (input === undefined) {\n        return new Date().toISOString();\n    }\n    return undefined;\n}"
  },
  {
    "type": "Function",
    "name": "$toDateTime",
    "description": "Parses the number of milliseconds since the Unix epoch or parses a string (with or without specified format) and returns the date and time in the ISO 8601 format.",
    "args": "input, format",
    "returns": "string",
    "code": "(input, format) => {\n    if (typeof input === 'number') {\n        return new Date(input).toISOString();\n    }\n    if (typeof input === 'string') {\n        if (format) {\n            // Add UTC as timezone if not provided\n            const _format = (format.includes('x') || format.includes('X')) ? format : `${format} X`;\n            const _input = (format.includes('x') || format.includes('X')) ? input : `${input} Z`;\n            return (0, date_fns_1.parse)(_input, _format, new Date()).toISOString();\n        }\n        return new Date(input).toISOString();\n    }\n    if (input === undefined) {\n        return new Date().toISOString();\n    }\n    return undefined;\n}"
  },
  {
    "type": "Function",
    "name": "dateTimeString",
    "description": "Parses the number of milliseconds since the Unix epoch or parses a string (with or without specified format) and returns the date and time in the ISO 8601 format.",
    "args": "input, format",
    "returns": "string",
    "code": "(input, format) => {\n    if (typeof input === 'number') {\n        return new Date(input).toISOString();\n    }\n    if (typeof input === 'string') {\n        if (format) {\n            // Add UTC as timezone if not provided\n            const _format = (format.includes('x') || format.includes('X')) ? format : `${format} X`;\n            const _input = (format.includes('x') || format.includes('X')) ? input : `${input} Z`;\n            return (0, date_fns_1.parse)(_input, _format, new Date()).toISOString();\n        }\n        return new Date(input).toISOString();\n    }\n    if (input === undefined) {\n        return new Date().toISOString();\n    }\n    return undefined;\n}"
  },
  {
    "type": "Function",
    "name": "dateTimeToMillis",
    "description": "Parses the date and time in the ISO 8601 format and returns the number of milliseconds since the Unix epoch.",
    "args": "input",
    "returns": "number",
    "code": "(input) => {\n    return new Date(input).getTime();\n}"
  },
  {
    "type": "Function",
    "name": "$dateTimeToMillis",
    "description": "Parses the date and time in the ISO 8601 format and returns the number of milliseconds since the Unix epoch.",
    "args": "input",
    "returns": "number",
    "code": "(input) => {\n    return new Date(input).getTime();\n}"
  },
  {
    "type": "Function",
    "name": "toMillis",
    "description": "Parses the date and time in the ISO 8601 format and returns the number of milliseconds since the Unix epoch.",
    "args": "input",
    "returns": "number",
    "code": "(input) => {\n    return new Date(input).getTime();\n}"
  },
  {
    "type": "Function",
    "name": "$toMillis",
    "description": "Parses the date and time in the ISO 8601 format and returns the number of milliseconds since the Unix epoch.",
    "args": "input",
    "returns": "number",
    "code": "(input) => {\n    return new Date(input).getTime();\n}"
  },
  {
    "type": "Function",
    "name": "dateTimeAdd",
    "description": "Adds a time range to a date and time in the ISO 8601 format.",
    "args": "input, unit, value",
    "returns": "string",
    "code": "(input, unit, value) => {\n    // if unit doesn't end with 's' add it\n    const _unit = unit.toLowerCase().endsWith('s') ? unit.toLowerCase() : `${unit.toLowerCase()}s`;\n    const returnDate = (0, date_fns_1.add)(new Date(input), { [_unit]: value });\n    return returnDate.toISOString();\n    // dateAdd(new Date(input), { [unit]: value });\n}"
  },
  {
    "type": "Function",
    "name": "$dateTimeAdd",
    "description": "Adds a time range to a date and time in the ISO 8601 format.",
    "args": "input, unit, value",
    "returns": "string",
    "code": "(input, unit, value) => {\n    // if unit doesn't end with 's' add it\n    const _unit = unit.toLowerCase().endsWith('s') ? unit.toLowerCase() : `${unit.toLowerCase()}s`;\n    const returnDate = (0, date_fns_1.add)(new Date(input), { [_unit]: value });\n    return returnDate.toISOString();\n    // dateAdd(new Date(input), { [unit]: value });\n}"
  },
  {
    "type": "Function",
    "name": "eval",
    "description": "Evaluate provided and return the result.\r\nIf only one argument is provided, it is expected that the first argument is a JEXL expression.\r\nIf two arguments are provided, the first argument is the context (must be an object) and the second argument is the JEXL expression.\r\nThe expression uses the default JEXL extended grammar and can't use any custom defined functions or transforms.",
    "args": "input, expression",
    "returns": "any",
    "code": "(input, expression) => {\n    if (expression === undefined) {\n        const _input = typeof input === 'string' ? input : JSON.stringify(input);\n        return _1.default.evalSync(_input);\n    }\n    if (typeof input === 'object') {\n        return _1.default.evalSync(expression, input);\n    }\n    return undefined;\n}"
  },
  {
    "type": "Function",
    "name": "$eval",
    "description": "Evaluate provided and return the result.\r\nIf only one argument is provided, it is expected that the first argument is a JEXL expression.\r\nIf two arguments are provided, the first argument is the context (must be an object) and the second argument is the JEXL expression.\r\nThe expression uses the default JEXL extended grammar and can't use any custom defined functions or transforms.",
    "args": "input, expression",
    "returns": "any",
    "code": "(input, expression) => {\n    if (expression === undefined) {\n        const _input = typeof input === 'string' ? input : JSON.stringify(input);\n        return _1.default.evalSync(_input);\n    }\n    if (typeof input === 'object') {\n        return _1.default.evalSync(expression, input);\n    }\n    return undefined;\n}"
  },
  {
    "type": "Function",
    "name": "uuid",
    "description": "Generate a new UUID (Universally Unique Identifier).",
    "returns": "string",
    "code": "() => {\n    return (0, uuid_1.v4)();\n}"
  },
  {
    "type": "Function",
    "name": "$uuid",
    "description": "Generate a new UUID (Universally Unique Identifier).",
    "returns": "string",
    "code": "() => {\n    return (0, uuid_1.v4)();\n}"
  },
  {
    "type": "Function",
    "name": "uid",
    "description": "Generate a new UUID (Universally Unique Identifier).",
    "returns": "string",
    "code": "() => {\n    return (0, uuid_1.v4)();\n}"
  },
  {
    "type": "Function",
    "name": "$uid",
    "description": "Generate a new UUID (Universally Unique Identifier).",
    "returns": "string",
    "code": "() => {\n    return (0, uuid_1.v4)();\n}"
  },
  {
    "type": "Transform",
    "name": "string",
    "description": "Casts the input to a string.",
    "args": "input, prettify",
    "returns": "string",
    "code": "(input, prettify = false) => {\n    return JSON.stringify(input, null, prettify ? 2 : 0);\n}"
  },
  {
    "type": "Transform",
    "name": "length",
    "description": "Returns the number of characters in a string, or the length of an array.",
    "args": "input",
    "returns": "number",
    "code": "(input) => {\n    if (typeof input === 'string') {\n        return input.length;\n    }\n    if (Array.isArray(input)) {\n        return input.length;\n    }\n    if (typeof input === 'object' && input !== null) {\n        return Object.keys(input).length;\n    }\n    return 0;\n}"
  },
  {
    "type": "Transform",
    "name": "count",
    "description": "Returns the number of characters in a string, or the length of an array.",
    "args": "input",
    "returns": "number",
    "code": "(input) => {\n    if (typeof input === 'string') {\n        return input.length;\n    }\n    if (Array.isArray(input)) {\n        return input.length;\n    }\n    if (typeof input === 'object' && input !== null) {\n        return Object.keys(input).length;\n    }\n    return 0;\n}"
  },
  {
    "type": "Transform",
    "name": "size",
    "description": "Returns the number of characters in a string, or the length of an array.",
    "args": "input",
    "returns": "number",
    "code": "(input) => {\n    if (typeof input === 'string') {\n        return input.length;\n    }\n    if (Array.isArray(input)) {\n        return input.length;\n    }\n    if (typeof input === 'object' && input !== null) {\n        return Object.keys(input).length;\n    }\n    return 0;\n}"
  },
  {
    "type": "Transform",
    "name": "substring",
    "description": "Gets a substring of a string.",
    "args": "input, start, length",
    "returns": "string",
    "code": "(input, start, length) => {\n    let str = input;\n    if (typeof str !== 'string') {\n        str = JSON.stringify(str);\n    }\n    if (typeof str === 'string') {\n        let startNum = start;\n        let len = length !== null && length !== void 0 ? length : str.length;\n        if (startNum < 0) {\n            startNum = str.length + start;\n            if (startNum < 0) {\n                startNum = 0;\n            }\n        }\n        if (startNum + len > str.length) {\n            len = str.length - startNum;\n        }\n        if (len < 0) {\n            len = 0;\n        }\n        return str.substring(startNum, startNum + len);\n    }\n    return '';\n}"
  },
  {
    "type": "Transform",
    "name": "substringBefore",
    "description": "Returns the substring before the first occurrence of the character sequence chars in str.",
    "args": "input, chars",
    "returns": "string",
    "code": "(input, chars) => {\n    const str = typeof input === 'string' ? input : JSON.stringify(input);\n    const charsStr = typeof chars === 'string' ? chars : JSON.stringify(chars);\n    const index = str.indexOf(charsStr);\n    if (index === -1) {\n        return str;\n    }\n    return str.substring(0, index);\n}"
  },
  {
    "type": "Transform",
    "name": "substringAfter",
    "description": "Returns the substring after the first occurrence of the character sequence chars in str.",
    "args": "input, chars",
    "returns": "string",
    "code": "(input, chars) => {\n    const str = typeof input === 'string' ? input : JSON.stringify(input);\n    const charsStr = typeof chars === 'string' ? chars : JSON.stringify(chars);\n    const index = str.indexOf(charsStr);\n    if (index === -1) {\n        return '';\n    }\n    return str.substring(index + charsStr.length);\n}"
  },
  {
    "type": "Transform",
    "name": "uppercase",
    "description": "Converts the input string to uppercase.",
    "args": "input",
    "returns": "string",
    "code": "(input) => {\n    const str = typeof input === 'string' ? input : JSON.stringify(input);\n    return str.toUpperCase();\n}"
  },
  {
    "type": "Transform",
    "name": "upper",
    "description": "Converts the input string to uppercase.",
    "args": "input",
    "returns": "string",
    "code": "(input) => {\n    const str = typeof input === 'string' ? input : JSON.stringify(input);\n    return str.toUpperCase();\n}"
  },
  {
    "type": "Transform",
    "name": "lowercase",
    "description": "Converts the input string to lowercase.",
    "args": "input",
    "returns": "string",
    "code": "(input) => {\n    const str = typeof input === 'string' ? input : JSON.stringify(input);\n    return str.toLowerCase();\n}"
  },
  {
    "type": "Transform",
    "name": "lower",
    "description": "Converts the input string to lowercase.",
    "args": "input",
    "returns": "string",
    "code": "(input) => {\n    const str = typeof input === 'string' ? input : JSON.stringify(input);\n    return str.toLowerCase();\n}"
  },
  {
    "type": "Transform",
    "name": "camelcase",
    "description": "Converts the input string to camel case.",
    "args": "input",
    "returns": "string",
    "code": "(input) => {\n    if (typeof input !== 'string')\n        return '';\n    return input.split(splitRegex).map((word, index) => {\n        if (index === 0)\n            return word.toLowerCase();\n        return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();\n    }).join('');\n}"
  },
  {
    "type": "Transform",
    "name": "camelCase",
    "description": "Converts the input string to camel case.",
    "args": "input",
    "returns": "string",
    "code": "(input) => {\n    if (typeof input !== 'string')\n        return '';\n    return input.split(splitRegex).map((word, index) => {\n        if (index === 0)\n            return word.toLowerCase();\n        return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();\n    }).join('');\n}"
  },
  {
    "type": "Transform",
    "name": "toCamelCase",
    "description": "Converts the input string to camel case.",
    "args": "input",
    "returns": "string",
    "code": "(input) => {\n    if (typeof input !== 'string')\n        return '';\n    return input.split(splitRegex).map((word, index) => {\n        if (index === 0)\n            return word.toLowerCase();\n        return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();\n    }).join('');\n}"
  },
  {
    "type": "Transform",
    "name": "pascalcase",
    "description": "Converts the input string to pascal case.",
    "args": "input",
    "returns": "string",
    "code": "(input) => {\n    if (typeof input !== 'string')\n        return '';\n    return input.split(splitRegex).map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()).join('');\n}"
  },
  {
    "type": "Transform",
    "name": "pascalCase",
    "description": "Converts the input string to pascal case.",
    "args": "input",
    "returns": "string",
    "code": "(input) => {\n    if (typeof input !== 'string')\n        return '';\n    return input.split(splitRegex).map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()).join('');\n}"
  },
  {
    "type": "Transform",
    "name": "toPascalCase",
    "description": "Converts the input string to pascal case.",
    "args": "input",
    "returns": "string",
    "code": "(input) => {\n    if (typeof input !== 'string')\n        return '';\n    return input.split(splitRegex).map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()).join('');\n}"
  },
  {
    "type": "Transform",
    "name": "trim",
    "description": "Trims whitespace from both ends of a string.",
    "args": "input",
    "returns": "string",
    "code": "(input) => {\n    if (typeof input === 'string') {\n        return input.trim();\n    }\n    return '';\n}"
  },
  {
    "type": "Transform",
    "name": "pad",
    "description": "Pads the input string on both sides to center it.",
    "args": "input, width, char",
    "returns": "string",
    "code": "(input, width, char = ' ') => {\n    const str = typeof input !== 'string' ? JSON.stringify(input) : input;\n    if (width > 0) {\n        return str.padEnd(width, char);\n    }\n    else {\n        return str.padStart(-width, char);\n    }\n}"
  },
  {
    "type": "Transform",
    "name": "contains",
    "description": "Checks if the input string contains the specified substring.",
    "args": "input, search",
    "returns": "boolean",
    "code": "(input, search) => {\n    if (typeof input === 'string' || Array.isArray(input)) {\n        return input.includes(search);\n    }\n    return false;\n}"
  },
  {
    "type": "Transform",
    "name": "includes",
    "description": "Checks if the input string contains the specified substring.",
    "args": "input, search",
    "returns": "boolean",
    "code": "(input, search) => {\n    if (typeof input === 'string' || Array.isArray(input)) {\n        return input.includes(search);\n    }\n    return false;\n}"
  },
  {
    "type": "Transform",
    "name": "split",
    "description": "Splits the input string into an array of substrings.",
    "args": "input, separator",
    "returns": "array",
    "code": "(input, separator) => {\n    if (typeof input === 'string') {\n        return input.split(separator);\n    }\n    return [];\n}"
  },
  {
    "type": "Transform",
    "name": "join",
    "description": "Joins elements of an array into a string.",
    "args": "input, separator",
    "returns": "string",
    "code": "(input, separator) => {\n    if (Array.isArray(input)) {\n        return input.join(separator);\n    }\n    return undefined;\n}"
  },
  {
    "type": "Transform",
    "name": "replace",
    "description": "Replaces occurrences of a specified string.",
    "args": "input, search, replacement",
    "returns": "string",
    "code": "(input, search, replacement) => {\n    if (typeof input === 'string' && typeof search === 'string') {\n        const _replacement = replacement === undefined ? '' : replacement;\n        return input.replace(new RegExp(search, 'g'), _replacement);\n    }\n    return undefined;\n}"
  },
  {
    "type": "Transform",
    "name": "base64Encode",
    "description": "Encodes a string to Base64.",
    "args": "input",
    "returns": "string",
    "code": "(input) => {\n    if (typeof input === 'string') {\n        return Buffer.from(input).toString('base64');\n    }\n    return '';\n}"
  },
  {
    "type": "Transform",
    "name": "base64Decode",
    "description": "Decodes a Base64 encoded string.",
    "args": "input",
    "returns": "string",
    "code": "(input) => {\n    if (typeof input === 'string') {\n        return Buffer.from(input, 'base64').toString('utf-8');\n    }\n    return '';\n}"
  },
  {
    "type": "Transform",
    "name": "number",
    "description": "Converts the input to a number.",
    "args": "input",
    "returns": "number",
    "code": "(input) => {\n    if (typeof input === 'number')\n        return input;\n    if (typeof input === 'string')\n        return parseFloat(input);\n    return NaN;\n}"
  },
  {
    "type": "Transform",
    "name": "toNumber",
    "description": "Converts the input to a number.",
    "args": "input",
    "returns": "number",
    "code": "(input) => {\n    if (typeof input === 'number')\n        return input;\n    if (typeof input === 'string')\n        return parseFloat(input);\n    return NaN;\n}"
  },
  {
    "type": "Transform",
    "name": "abs",
    "description": "Returns the absolute value of a number.",
    "args": "input",
    "returns": "number",
    "code": "(input) => {\n    const num = (0, exports.toNumber)(input);\n    return isNaN(num) ? NaN : Math.abs(num);\n}"
  },
  {
    "type": "Transform",
    "name": "floor",
    "description": "Rounds a number down to the nearest integer.",
    "args": "input",
    "returns": "number",
    "code": "(input) => {\n    const num = (0, exports.toNumber)(input);\n    return isNaN(num) ? NaN : Math.floor(num);\n}"
  },
  {
    "type": "Transform",
    "name": "ceil",
    "description": "Rounds a number up to the nearest integer.",
    "args": "input",
    "returns": "number",
    "code": "(input) => {\n    const num = (0, exports.toNumber)(input);\n    return isNaN(num) ? NaN : Math.ceil(num);\n}"
  },
  {
    "type": "Transform",
    "name": "round",
    "description": "Rounds a number to the nearest integer.",
    "args": "input, decimals",
    "returns": "number",
    "code": "(input, decimals) => {\n    const num = (0, exports.toNumber)(input);\n    return isNaN(num) ? NaN : decimals ? Math.round(num * Math.pow(10, decimals)) / Math.pow(10, decimals) : Math.round(num);\n}"
  },
  {
    "type": "Transform",
    "name": "power",
    "description": "Returns the value of a number raised to a power.",
    "args": "input, exponent",
    "returns": "number",
    "code": "(input, exponent) => {\n    const num = (0, exports.toNumber)(input);\n    const exp = exponent === undefined ? 2 : exponent;\n    return isNaN(num) ? NaN : Math.pow(num, exp);\n}"
  },
  {
    "type": "Transform",
    "name": "sqrt",
    "description": "Returns the square root of a number.",
    "args": "input",
    "returns": "number",
    "code": "(input) => {\n    const num = (0, exports.toNumber)(input);\n    return isNaN(num) ? NaN : Math.sqrt(num);\n}"
  },
  {
    "type": "Transform",
    "name": "formatNumber",
    "description": "Casts the number to a string and formats it to a decimal representation as specified by the format string.",
    "args": "input, format",
    "returns": "string",
    "code": "(input, format) => {\n    var _a, _b, _c;\n    const num = typeof input === 'number' ? input : parseInt((0, exports.toNumber)(input).toString(), 10);\n    return isNaN(num) ? '' : num.toLocaleString('en-us', {\n        minimumFractionDigits: (_a = format.split('.')[1]) === null || _a === void 0 ? void 0 : _a.length,\n        maximumFractionDigits: (_b = format.split('.')[1]) === null || _b === void 0 ? void 0 : _b.length,\n        useGrouping: (_c = format.split('.')[0]) === null || _c === void 0 ? void 0 : _c.includes(',')\n    });\n}"
  },
  {
    "type": "Transform",
    "name": "formatBase",
    "description": "Formats a number as a string in the specified base.",
    "args": "input, base",
    "returns": "string",
    "code": "(input, base) => {\n    const num = typeof input === 'number' ? input : parseInt((0, exports.toNumber)(input).toString(), 10);\n    return isNaN(num) ? '' : num.toString(base);\n}"
  },
  {
    "type": "Transform",
    "name": "formatInteger",
    "description": "Formats a number as an integer.",
    "args": "input, format",
    "returns": "string",
    "code": "(input, format) => {\n    const num = (0, exports.toNumber)(input);\n    return isNaN(num) ? '' : (0, exports.pad)(Math.floor(num).toString(), -format.length, '0');\n}"
  },
  {
    "type": "Transform",
    "name": "parseInteger",
    "description": "Parses a string and returns an integer.",
    "args": "input",
    "returns": "number",
    "code": "(input) => {\n    if (typeof input === 'string') {\n        return parseInt(input, 10);\n    }\n    else if (typeof input === 'number') {\n        return Math.floor(input);\n    }\n    return NaN;\n}"
  },
  {
    "type": "Transform",
    "name": "parseInt",
    "description": "Parses a string and returns an integer.",
    "args": "input",
    "returns": "number",
    "code": "(input) => {\n    if (typeof input === 'string') {\n        return parseInt(input, 10);\n    }\n    else if (typeof input === 'number') {\n        return Math.floor(input);\n    }\n    return NaN;\n}"
  },
  {
    "type": "Transform",
    "name": "toInt",
    "description": "Parses a string and returns an integer.",
    "args": "input",
    "returns": "number",
    "code": "(input) => {\n    if (typeof input === 'string') {\n        return parseInt(input, 10);\n    }\n    else if (typeof input === 'number') {\n        return Math.floor(input);\n    }\n    return NaN;\n}"
  },
  {
    "type": "Transform",
    "name": "sum",
    "description": "Calculates the sum of an array of numbers.",
    "args": "input",
    "returns": "number",
    "code": "(...input) => {\n    if (!Array.isArray(input))\n        return NaN;\n    return input.flat().reduce((acc, val) => acc + (0, exports.toNumber)(val), 0);\n}"
  },
  {
    "type": "Transform",
    "name": "max",
    "description": "Finds the maximum value in an array of numbers.",
    "args": "input",
    "returns": "number",
    "code": "(...input) => {\n    if (!Array.isArray(input))\n        return NaN;\n    return Math.max(...input.flat().map(exports.toNumber));\n}"
  },
  {
    "type": "Transform",
    "name": "min",
    "description": "Finds the minimum value in an array of numbers.",
    "args": "input",
    "returns": "number",
    "code": "(...input) => {\n    if (!Array.isArray(input))\n        return NaN;\n    return Math.min(...input.flat().map(exports.toNumber));\n}"
  },
  {
    "type": "Transform",
    "name": "average",
    "description": "Calculates the average of an array of numbers.",
    "args": "input",
    "returns": "number",
    "code": "(...input) => {\n    if (!Array.isArray(input))\n        return NaN;\n    const total = (0, exports.sum)(...input);\n    return total / input.flat().length;\n}"
  },
  {
    "type": "Transform",
    "name": "avg",
    "description": "Calculates the average of an array of numbers.",
    "args": "input",
    "returns": "number",
    "code": "(...input) => {\n    if (!Array.isArray(input))\n        return NaN;\n    const total = (0, exports.sum)(...input);\n    return total / input.flat().length;\n}"
  },
  {
    "type": "Transform",
    "name": "boolean",
    "description": "Converts the input to a boolean.",
    "args": "input",
    "returns": "boolean",
    "code": "(input) => {\n    if (typeof input === 'boolean')\n        return input;\n    if (typeof input === 'number')\n        return input !== 0;\n    if (typeof input === 'string') {\n        if (input.trim().toLowerCase() === 'true' || input.trim() === '1')\n            return true;\n        if (input.trim().toLowerCase() === 'false' || input.trim() === '0')\n            return false;\n        else\n            return undefined;\n    }\n    return Boolean(input);\n}"
  },
  {
    "type": "Transform",
    "name": "bool",
    "description": "Converts the input to a boolean.",
    "args": "input",
    "returns": "boolean",
    "code": "(input) => {\n    if (typeof input === 'boolean')\n        return input;\n    if (typeof input === 'number')\n        return input !== 0;\n    if (typeof input === 'string') {\n        if (input.trim().toLowerCase() === 'true' || input.trim() === '1')\n            return true;\n        if (input.trim().toLowerCase() === 'false' || input.trim() === '0')\n            return false;\n        else\n            return undefined;\n    }\n    return Boolean(input);\n}"
  },
  {
    "type": "Transform",
    "name": "toBoolean",
    "description": "Converts the input to a boolean.",
    "args": "input",
    "returns": "boolean",
    "code": "(input) => {\n    if (typeof input === 'boolean')\n        return input;\n    if (typeof input === 'number')\n        return input !== 0;\n    if (typeof input === 'string') {\n        if (input.trim().toLowerCase() === 'true' || input.trim() === '1')\n            return true;\n        if (input.trim().toLowerCase() === 'false' || input.trim() === '0')\n            return false;\n        else\n            return undefined;\n    }\n    return Boolean(input);\n}"
  },
  {
    "type": "Transform",
    "name": "toBool",
    "description": "Converts the input to a boolean.",
    "args": "input",
    "returns": "boolean",
    "code": "(input) => {\n    if (typeof input === 'boolean')\n        return input;\n    if (typeof input === 'number')\n        return input !== 0;\n    if (typeof input === 'string') {\n        if (input.trim().toLowerCase() === 'true' || input.trim() === '1')\n            return true;\n        if (input.trim().toLowerCase() === 'false' || input.trim() === '0')\n            return false;\n        else\n            return undefined;\n    }\n    return Boolean(input);\n}"
  },
  {
    "type": "Transform",
    "name": "not",
    "description": "Returns the logical NOT of the input.",
    "args": "input",
    "returns": "boolean",
    "code": "(input) => {\n    return !(0, exports.toBoolean)(input);\n}"
  },
  {
    "type": "Transform",
    "name": "append",
    "description": "Appends an element to an array.",
    "args": "input",
    "returns": "array",
    "code": "(...input) => {\n    if (!Array.isArray(input))\n        return [];\n    return [...input.flat()];\n}"
  },
  {
    "type": "Transform",
    "name": "concat",
    "description": "Appends an element to an array.",
    "args": "input",
    "returns": "array",
    "code": "(...input) => {\n    if (!Array.isArray(input))\n        return [];\n    return [...input.flat()];\n}"
  },
  {
    "type": "Transform",
    "name": "reverse",
    "description": "Reverses the elements of an array.",
    "args": "input",
    "returns": "array",
    "code": "(...input) => {\n    if (!Array.isArray(input))\n        return [];\n    return [...input.flat()].reverse();\n}"
  },
  {
    "type": "Transform",
    "name": "shuffle",
    "description": "Shuffles the elements of an array.",
    "args": "input",
    "returns": "array",
    "code": "(input) => {\n    if (!Array.isArray(input))\n        return [];\n    for (let i = input.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * (i + 1));\n        [input[i], input[j]] = [input[j], input[i]];\n    }\n    return input;\n}"
  },
  {
    "type": "Transform",
    "name": "sort",
    "description": "Sorts the elements of an array.",
    "args": "input, expression, descending",
    "returns": "array",
    "code": "(input, expression, descending) => {\n    if (!Array.isArray(input))\n        return [];\n    if (!expression)\n        return [...input].sort();\n    const expr = _1.default.compile(expression);\n    const compareFunction = (a, b) => {\n        const aValue = expr.evalSync(a);\n        const bValue = expr.evalSync(b);\n        if (aValue < bValue)\n            return descending ? -1 : 1;\n        if (aValue > bValue)\n            return descending ? 1 : -1;\n        return 0;\n    };\n    return [...input].sort(compareFunction);\n}"
  },
  {
    "type": "Transform",
    "name": "order",
    "description": "Sorts the elements of an array.",
    "args": "input, expression, descending",
    "returns": "array",
    "code": "(input, expression, descending) => {\n    if (!Array.isArray(input))\n        return [];\n    if (!expression)\n        return [...input].sort();\n    const expr = _1.default.compile(expression);\n    const compareFunction = (a, b) => {\n        const aValue = expr.evalSync(a);\n        const bValue = expr.evalSync(b);\n        if (aValue < bValue)\n            return descending ? -1 : 1;\n        if (aValue > bValue)\n            return descending ? 1 : -1;\n        return 0;\n    };\n    return [...input].sort(compareFunction);\n}"
  },
  {
    "type": "Transform",
    "name": "distinct",
    "description": "Returns a new array with the elements of the input array with duplicates removed.",
    "args": "input",
    "returns": "array",
    "code": "(input) => {\n    if (!Array.isArray(input))\n        return [];\n    return [...new Set(input)];\n}"
  },
  {
    "type": "Transform",
    "name": "toObject",
    "description": "Create a new object based on an array of key-value pairs.",
    "args": "input, val",
    "returns": "any",
    "code": "(input, val) => {\n    if (typeof input === 'string')\n        return { [input]: val };\n    if (!Array.isArray(input))\n        return {};\n    return input.reduce((acc, kv) => {\n        if (Array.isArray(kv) && kv.length === 2) {\n            acc[kv[0]] = kv[1];\n            return acc;\n        }\n        else if (typeof kv === 'string') {\n            acc[kv] = val;\n            return acc;\n        }\n        return acc;\n    }, {});\n}"
  },
  {
    "type": "Transform",
    "name": "fromEntries",
    "description": "Create a new object based on an array of key-value pairs.",
    "args": "input, val",
    "returns": "any",
    "code": "(input, val) => {\n    if (typeof input === 'string')\n        return { [input]: val };\n    if (!Array.isArray(input))\n        return {};\n    return input.reduce((acc, kv) => {\n        if (Array.isArray(kv) && kv.length === 2) {\n            acc[kv[0]] = kv[1];\n            return acc;\n        }\n        else if (typeof kv === 'string') {\n            acc[kv] = val;\n            return acc;\n        }\n        return acc;\n    }, {});\n}"
  },
  {
    "type": "Transform",
    "name": "mapField",
    "description": "Returns a new array with the elements of the input array transformed by the specified map function.",
    "args": "input, field",
    "returns": "array",
    "code": "(input, field) => {\n    if (!Array.isArray(input))\n        return [];\n    return input.map(item => item[field]);\n}"
  },
  {
    "type": "Transform",
    "name": "map",
    "description": "Returns an array containing the results of applying the expression parameter to each value in the array parameter.\r\nThe expression must be a valid JEXL expression string, which is applied to each element of the array.\r\nThe relative context provided to the expression is an object with the properties value, index and array (the original array).",
    "args": "input, expression",
    "returns": "array",
    "code": "(input, expression) => {\n    if (!Array.isArray(input))\n        return undefined;\n    const expr = _1.default.compile(expression);\n    return input.map((value, index, array) => {\n        return expr.evalSync({ value, index, array });\n    });\n}"
  },
  {
    "type": "Transform",
    "name": "any",
    "description": "Checks whether the provided array has any elements that match the specified expression.\r\nThe expression must be a valid JEXL expression string, and is applied to each element of the array.\r\nThe relative context provided to the expression is an object with the properties value and array (the original array).",
    "args": "input, expression",
    "returns": "boolean",
    "code": "(input, expression) => {\n    if (!Array.isArray(input))\n        return false;\n    const expr = _1.default.compile(expression);\n    return input.some((value, index, array) => {\n        return expr.evalSync({ value, index, array });\n    });\n}"
  },
  {
    "type": "Transform",
    "name": "some",
    "description": "Checks whether the provided array has any elements that match the specified expression.\r\nThe expression must be a valid JEXL expression string, and is applied to each element of the array.\r\nThe relative context provided to the expression is an object with the properties value and array (the original array).",
    "args": "input, expression",
    "returns": "boolean",
    "code": "(input, expression) => {\n    if (!Array.isArray(input))\n        return false;\n    const expr = _1.default.compile(expression);\n    return input.some((value, index, array) => {\n        return expr.evalSync({ value, index, array });\n    });\n}"
  },
  {
    "type": "Transform",
    "name": "all",
    "description": "Checks whether the provided array has all elements that match the specified expression.\r\nThe expression must be a valid JEXL expression string, and is applied to each element of the array.\r\nThe relative context provided to the expression is an object with the properties value and array (the original array).",
    "args": "input, expression",
    "returns": "boolean",
    "code": "(input, expression) => {\n    if (!Array.isArray(input))\n        return false;\n    const expr = _1.default.compile(expression);\n    return input.every((value, index, array) => {\n        return expr.evalSync({ value, index, array });\n    });\n}"
  },
  {
    "type": "Transform",
    "name": "every",
    "description": "Checks whether the provided array has all elements that match the specified expression.\r\nThe expression must be a valid JEXL expression string, and is applied to each element of the array.\r\nThe relative context provided to the expression is an object with the properties value and array (the original array).",
    "args": "input, expression",
    "returns": "boolean",
    "code": "(input, expression) => {\n    if (!Array.isArray(input))\n        return false;\n    const expr = _1.default.compile(expression);\n    return input.every((value, index, array) => {\n        return expr.evalSync({ value, index, array });\n    });\n}"
  },
  {
    "type": "Transform",
    "name": "filter",
    "description": "Returns a new array with the elements of the input array that match the specified expression.\r\nThe expression must be a valid JEXL expression string, and is applied to each element of the array.\r\nThe relative context provided to the expression is an object with the properties value and array (the original array).",
    "args": "input, expression",
    "returns": "array",
    "code": "(input, expression) => {\n    if (!Array.isArray(input))\n        return [];\n    const expr = _1.default.compile(expression);\n    return input.filter((value, index, array) => {\n        return expr.evalSync({ value, index, array });\n    });\n}"
  },
  {
    "type": "Transform",
    "name": "find",
    "description": "Finds the first element in an array that matches the specified expression.\r\nThe expression must be a valid JEXL expression string, and is applied to each element of the array.\r\nThe relative context provided to the expression is an object with the properties value and array (the original array).",
    "args": "input, expression",
    "returns": "unknown",
    "code": "(input, expression) => {\n    if (!Array.isArray(input))\n        return undefined;\n    const expr = _1.default.compile(expression);\n    return input.find((value, index, array) => {\n        return expr.evalSync({ value, index, array });\n    });\n}"
  },
  {
    "type": "Transform",
    "name": "reduce",
    "description": "Returns an aggregated value derived from applying the function parameter successively to each value in array in combination with the result of the previous application of the function.\r\nThe expression must be a valid JEXL expression string, and behaves like an infix operator between each value within the array.\r\nThe relative context provided to the expression is an object with the properties accumulator, value, index and array (the original array).",
    "args": "input, expression, initialValue",
    "returns": "unknown",
    "code": "(input, expression, initialValue) => {\n    if (!Array.isArray(input))\n        return undefined;\n    const expr = _1.default.compile(expression);\n    return input.reduce((accumulator, value, index, array) => {\n        return expr.evalSync({ accumulator, value, index, array });\n    }, initialValue);\n}"
  },
  {
    "type": "Transform",
    "name": "keys",
    "description": "Returns the keys of an object.",
    "args": "input",
    "returns": "array",
    "code": "(input) => {\n    if (typeof input === 'object' && input !== null) {\n        return Object.keys(input);\n    }\n    return undefined;\n}"
  },
  {
    "type": "Transform",
    "name": "values",
    "description": "Returns the values of an object.",
    "args": "input",
    "returns": "array",
    "code": "(input) => {\n    if (typeof input === 'object' && input !== null) {\n        return Object.values(input);\n    }\n    return undefined;\n}"
  },
  {
    "type": "Transform",
    "name": "entries",
    "description": "Returns an array of key-value pairs from the input object.",
    "args": "input",
    "returns": "array",
    "code": "(input) => {\n    if (typeof input === 'object' && input !== null) {\n        return Object.entries(input);\n    }\n    return undefined;\n}"
  },
  {
    "type": "Transform",
    "name": "merge",
    "description": "Returns a new object with the properties of the input objects merged together.",
    "args": "args",
    "returns": "Record",
    "code": "(...args) => {\n    return args.reduce((acc, obj) => {\n        if (typeof obj === 'object' && obj !== null) {\n            return { ...acc, ...obj };\n        }\n        return acc;\n    }, {});\n}"
  },
  {
    "type": "Transform",
    "name": "millisToDateTime",
    "description": "Parses the number of milliseconds since the Unix epoch or parses a string (with or without specified format) and returns the date and time in the ISO 8601 format.",
    "args": "input, format",
    "returns": "string",
    "code": "(input, format) => {\n    if (typeof input === 'number') {\n        return new Date(input).toISOString();\n    }\n    if (typeof input === 'string') {\n        if (format) {\n            // Add UTC as timezone if not provided\n            const _format = (format.includes('x') || format.includes('X')) ? format : `${format} X`;\n            const _input = (format.includes('x') || format.includes('X')) ? input : `${input} Z`;\n            return (0, date_fns_1.parse)(_input, _format, new Date()).toISOString();\n        }\n        return new Date(input).toISOString();\n    }\n    if (input === undefined) {\n        return new Date().toISOString();\n    }\n    return undefined;\n}"
  },
  {
    "type": "Transform",
    "name": "fromMillis",
    "description": "Parses the number of milliseconds since the Unix epoch or parses a string (with or without specified format) and returns the date and time in the ISO 8601 format.",
    "args": "input, format",
    "returns": "string",
    "code": "(input, format) => {\n    if (typeof input === 'number') {\n        return new Date(input).toISOString();\n    }\n    if (typeof input === 'string') {\n        if (format) {\n            // Add UTC as timezone if not provided\n            const _format = (format.includes('x') || format.includes('X')) ? format : `${format} X`;\n            const _input = (format.includes('x') || format.includes('X')) ? input : `${input} Z`;\n            return (0, date_fns_1.parse)(_input, _format, new Date()).toISOString();\n        }\n        return new Date(input).toISOString();\n    }\n    if (input === undefined) {\n        return new Date().toISOString();\n    }\n    return undefined;\n}"
  },
  {
    "type": "Transform",
    "name": "toDateTime",
    "description": "Parses the number of milliseconds since the Unix epoch or parses a string (with or without specified format) and returns the date and time in the ISO 8601 format.",
    "args": "input, format",
    "returns": "string",
    "code": "(input, format) => {\n    if (typeof input === 'number') {\n        return new Date(input).toISOString();\n    }\n    if (typeof input === 'string') {\n        if (format) {\n            // Add UTC as timezone if not provided\n            const _format = (format.includes('x') || format.includes('X')) ? format : `${format} X`;\n            const _input = (format.includes('x') || format.includes('X')) ? input : `${input} Z`;\n            return (0, date_fns_1.parse)(_input, _format, new Date()).toISOString();\n        }\n        return new Date(input).toISOString();\n    }\n    if (input === undefined) {\n        return new Date().toISOString();\n    }\n    return undefined;\n}"
  },
  {
    "type": "Transform",
    "name": "dateTimeToMillis",
    "description": "Parses the date and time in the ISO 8601 format and returns the number of milliseconds since the Unix epoch.",
    "args": "input",
    "returns": "number",
    "code": "(input) => {\n    return new Date(input).getTime();\n}"
  },
  {
    "type": "Transform",
    "name": "toMillis",
    "description": "Parses the date and time in the ISO 8601 format and returns the number of milliseconds since the Unix epoch.",
    "args": "input",
    "returns": "number",
    "code": "(input) => {\n    return new Date(input).getTime();\n}"
  },
  {
    "type": "Transform",
    "name": "dateTimeAdd",
    "description": "Adds a time range to a date and time in the ISO 8601 format.",
    "args": "input, unit, value",
    "returns": "string",
    "code": "(input, unit, value) => {\n    // if unit doesn't end with 's' add it\n    const _unit = unit.toLowerCase().endsWith('s') ? unit.toLowerCase() : `${unit.toLowerCase()}s`;\n    const returnDate = (0, date_fns_1.add)(new Date(input), { [_unit]: value });\n    return returnDate.toISOString();\n    // dateAdd(new Date(input), { [unit]: value });\n}"
  },
  {
    "type": "Transform",
    "name": "eval",
    "description": "Evaluate provided and return the result.\r\nIf only one argument is provided, it is expected that the first argument is a JEXL expression.\r\nIf two arguments are provided, the first argument is the context (must be an object) and the second argument is the JEXL expression.\r\nThe expression uses the default JEXL extended grammar and can't use any custom defined functions or transforms.",
    "args": "input, expression",
    "returns": "any",
    "code": "(input, expression) => {\n    if (expression === undefined) {\n        const _input = typeof input === 'string' ? input : JSON.stringify(input);\n        return _1.default.evalSync(_input);\n    }\n    if (typeof input === 'object') {\n        return _1.default.evalSync(expression, input);\n    }\n    return undefined;\n}"
  }
]